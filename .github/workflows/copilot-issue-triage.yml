name: Copilot Issue Triage

on:
  issues:
    types: [opened, reopened]
  pull_request_target:
    types: [opened, edited, reopened, closed]

permissions:
  contents: read
  issues: write
  pull-requests: read

jobs:
  triage-new-bug-or-feature:
    if: >-
      github.event_name == 'issues' &&
      (contains(join(github.event.issue.labels.*.name, ','), 'bug') ||
       contains(join(github.event.issue.labels.*.name, ','), 'enhancement'))
    runs-on: ubuntu-latest
    steps:
      - name: Add needs-triage and ask Copilot for spec PR
        uses: actions/github-script@v7
        env:
          COPILOT_ASSIGNEE: ${{ vars.COPILOT_ASSIGNEE || 'Copilot' }}
        with:
          script: |
            const marker = '<!-- copilot-issue-triage -->';
            const { owner, repo } = context.repo;
            const issue_number = context.payload.issue.number;
            const desiredAssignee = process.env.COPILOT_ASSIGNEE;

            const allLabels = await github.paginate(github.rest.issues.listLabelsForRepo, {
              owner,
              repo,
              per_page: 100,
            });
            const hasNeedsTriage = allLabels.some((l) => l.name === 'needs-triage');
            if (!hasNeedsTriage) {
              await github.rest.issues.createLabel({
                owner,
                repo,
                name: 'needs-triage',
                color: 'd4c5f9',
                description: 'New issue waiting for triage/spec PR',
              });
            }

            const labels = context.payload.issue.labels.map((l) => l.name);
            if (!labels.includes('needs-triage')) {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number,
                labels: ['needs-triage'],
              });
            }

            const currentAssignees = (context.payload.issue.assignees || []).map((a) => a.login);
            if (desiredAssignee && !currentAssignees.includes(desiredAssignee)) {
              try {
                await github.rest.issues.addAssignees({
                  owner,
                  repo,
                  issue_number,
                  assignees: [desiredAssignee],
                });
              } catch (err) {
                core.warning(`Unable to assign ${desiredAssignee}: ${err.message}`);
              }
            }

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number,
              per_page: 100,
            });
            const alreadyPosted = comments.some((c) =>
              c.user?.login === 'github-actions[bot]' && c.body?.includes(marker)
            );
            if (alreadyPosted) return;

            const body = [
              marker,
              `Assigned \`${desiredAssignee}\` for triage.`,
              '',
              'Requirements:',
              '- Follow SDD workflow from `.github/copilot-instructions.md`.',
              '- Write/adjust spec artifacts under `specs/`.',
              '- Include acceptance criteria and verification commands.',
              '- Keep the PR focused on specification and plan artifacts first.',
              '',
              'When the linked spec PR is merged, automation will request Copilot implementation in this issue.',
              'You can still add a human-written `@copilot` comment to refine scope or priority.',
            ].join('\n');

            await github.rest.issues.createComment({ owner, repo, issue_number, body });

  request-implementation-after-spec-merge:
    if: >-
      github.event_name == 'pull_request_target' &&
      github.event.action == 'closed' &&
      github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - name: Promote linked issues to implementation with Copilot
        uses: actions/github-script@v7
        env:
          COPILOT_ASSIGNEE: ${{ vars.COPILOT_ASSIGNEE || 'Copilot' }}
        with:
          script: |
            const { owner, repo } = context.repo;
            const pr = context.payload.pull_request;
            if (!pr) return;

            const changedFiles = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number: pr.number,
              per_page: 100,
            });
            const isSpecPR = changedFiles.some((f) => f.filename.startsWith('specs/'));
            if (!isSpecPR) return;

            const body = pr.body || '';

            const allLabels = await github.paginate(github.rest.issues.listLabelsForRepo, {
              owner,
              repo,
              per_page: 100,
            });
            const hasReadyLabel = allLabels.some((l) => l.name === 'ready-for-implementation');
            if (!hasReadyLabel) {
              await github.rest.issues.createLabel({
                owner,
                repo,
                name: 'ready-for-implementation',
                color: '0e8a16',
                description: 'Spec merged, ready for implementation',
              });
            }

            const regex = /(?:close[sd]?|fix(?:e[sd])?|resolve[sd]?|ref(?:er(?:s|enced)?)?|relate(?:s|d)?\s+to)\s+#(\d+)/ig;
            const issueNumbers = new Set();
            let match;
            while ((match = regex.exec(body)) !== null) {
              issueNumbers.add(Number(match[1]));
            }

            if (issueNumbers.size === 0) return;

            const desiredAssignee = process.env.COPILOT_ASSIGNEE;
            const marker = `<!-- copilot-implement-from-spec-pr-${pr.number} -->`;

            for (const issue_number of issueNumbers) {
              try {
                await github.rest.issues.removeLabel({
                  owner,
                  repo,
                  issue_number,
                  name: 'needs-triage',
                });
              } catch (err) {
                if (err.status !== 404) throw err;
              }

              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number,
                labels: ['ready-for-implementation'],
              });

              if (desiredAssignee) {
                try {
                  await github.rest.issues.addAssignees({
                    owner,
                    repo,
                    issue_number,
                    assignees: [desiredAssignee],
                  });
                } catch (err) {
                  core.warning(`Unable to assign ${desiredAssignee} on issue #${issue_number}: ${err.message}`);
                }
              }

              const comments = await github.paginate(github.rest.issues.listComments, {
                owner,
                repo,
                issue_number,
                per_page: 100,
              });
              const alreadyPosted = comments.some((c) =>
                c.user?.login === 'github-actions[bot]' && c.body?.includes(marker)
              );
              if (alreadyPosted) continue;

              const comment = [
                marker,
                `@copilot please implement this issue based on merged spec PR #${pr.number}.`,
                '',
                'Implementation rules:',
                '- Follow `.github/copilot-instructions.md` SDD workflow.',
                '- Implement spec artifacts under `specs/` linked to this issue.',
                '- Add/update tests for acceptance criteria.',
                '- Open or update a PR with implementation + verification results.',
              ].join('\n');

              await github.rest.issues.createComment({ owner, repo, issue_number, body: comment });
            }
